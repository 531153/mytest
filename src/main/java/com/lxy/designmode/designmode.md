设计原则
工厂方法模式
抽象工厂模式
### 单例模式
    通过单例模式可以保证系统中，应用该模式的一个类只有一个实例，即一个类只有一个对象实例。
    实现方式：
    1. 饿汉式(static,实例在类加载的时候即被实例化，因此线程安全)
    2. 懒汉式(在使用时加载，多线程不安全)
    3. 懒汉式单例模式+同步方法(synchronized性能差，不推荐使用)
    4. 懒汉式单例模式+同步代码块（不可用，线程不安全）
    5. DCL(双重锁)单例模式+Volatile（可用，懒加载，线程安全）
    6. holder静态内部类(类似懒汉式，但是实现懒加载)
    7. Enum单例模式(利用enum枚举类的特性，解决线程安全问题)
    **破坏单例的3种方式**
    1、反射 --定义一个全局变量，当第二次创建的时候抛出异常
    2、序列化 --重写clone(),直接返回单例对象 
    3、克隆 --添加readResolve(),返回Object对象
建造者模式
原型模式
适配器模式
装饰器模式
代理模式
外观模式
桥接模式
### 组合模式
    有时，将容器和内容作为同一种东西看待，可以很好地帮助我们处理问题，在容器中既可以存放内容，也可以存放小容器，
    然后在小容器中，又可以继续放入更小的容器。这样，这样就形成了容器结构、递归结构。创造出这样结构的模式
    就是组合模式（Composite），能够使容器和内存具有一致性，创造出递归结构的模式。
策略模式
模板方法模式
观察者模式
迭代子模式
责任链模式
命令模式
备忘录模式
状态模式
### 访问者模式
    我们在对类中数据结构执行操作A时，一般会在该类中声明一个方法来完成操作A。但是当需要增加另一种操作B时，
    就需要再增加一个方法。那么在后续不断增加需求过程中，我们就需要不断地去修改这个类，这样就很不符合开闭原则。
    那么我们能不能把数据结构和操作分开，当需要增加操作需求时，只需修改操作类呢？
    访问模式就可以实现这样的需求。在该模式中，数据结构与处理被分离开来。编写一个
    表示“访问者”的类来访问数据 中的元素,并把对各元素的处理交给访问者类。这样,当需要增加新的处理时,
    我们只需要修改访问者,然后让数据结构可以接受访问者的访问即可。
中介者模式
解释器模式