### 工厂方法模式
    定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法是一个类的实例化延迟到其子类
### 抽象工厂模式
    抽象工厂模式，对工厂方法模式进行了升级。对产品进行了进一步的抽象，同时改变了抽象工厂
    和具体工厂的设计模式。这种模式便于横向的扩展。
### 单例模式
    通过单例模式可以保证系统中，应用该模式的一个类只有一个实例，即一个类只有一个对象实例。
    实现方式：
    1. 饿汉式(static,实例在类加载的时候即被实例化，因此线程安全)
    2. 懒汉式(在使用时加载，多线程不安全)
    3. 懒汉式单例模式+同步方法(synchronized性能差，不推荐使用)
    4. 懒汉式单例模式+同步代码块（不可用，线程不安全）
    5. DCL(双重锁)单例模式+Volatile（可用，懒加载，线程安全）
    6. holder静态内部类(类似懒汉式，但是实现懒加载)
    7. Enum单例模式(利用enum枚举类的特性，解决线程安全问题)
    **破坏单例的3种方式**
    1、反射 --定义一个全局变量，当第二次创建的时候抛出异常
    2、序列化 --重写clone(),直接返回单例对象 
    3、克隆 --添加readResolve(),返回Object对象
### 建造者模式
### 原型模式
### 适配器模式
### 装饰器模式
### 代理模式
### 外观模式
### 桥接模式
### 组合模式
    有时，将容器和内容作为同一种东西看待，可以很好地帮助我们处理问题，在容器中既可以存放内容，也可以存放小容器，
    然后在小容器中，又可以继续放入更小的容器。这样，这样就形成了容器结构、递归结构。创造出这样结构的模式
    就是组合模式（Composite），能够使容器和内存具有一致性，创造出递归结构的模式。
### 策略模式
    策略模式把对象本身和运算规则区分开来，因此我们整个模式也分为三个部分。
    环境类(Context):用来操作策略的上下文环境，也就是我们游客。
    抽象策略类(Strategy):策略的抽象，出行方式的抽象
    具体策略类(ConcreteStrategy):具体的策略实现，每一种出行方式的具体实现。
### 模板方法模式
### 观察者模式
    在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。
    观察者模式主要有两个角色
    Subject 观察主题对象，也可以叫被观察或者被订阅对象
    Observer 观察者或者订阅者对象，当Subject有变动，就会通知到每一个Observer
### 迭代子模式
### 责任链模式
### 命令模式
    命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。
    **命令模式组成结构:**
    命令接口 (Command)：定义命令的接口，声明执行的方法。
    具体命令 (ConcreteCommand)：命令接口实现对象，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。
    接受者 (Receiver)：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。
    调用者 (Invoker)：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。
    客户 (Client)：创建具体的命令对象，并且设置命令对象的接收者。注意这个不是我们常规意义上的客户端，而是在组装命令对象和接收者，或许，把这个 Client 称为装配者会更好理解，因为真正使用命令的客户端是从 Invoker 来触发执行。
    [命令模式](https://segmentfault.com/a/1190000016609033)
### 备忘录模式
### 状态模式
    对象行为的变化是由于状态的变化引入，那么即当内部状态发生变化的时候，就会改变对象的行为，而这种改变视乎就改变了整个类。
    角色：抽象状态，具体状态，环境(context)角色
### 访问者模式
    我们在对类中数据结构执行操作A时，一般会在该类中声明一个方法来完成操作A。但是当需要增加另一种操作B时，
    就需要再增加一个方法。那么在后续不断增加需求过程中，我们就需要不断地去修改这个类，这样就很不符合开闭原则。
    那么我们能不能把数据结构和操作分开，当需要增加操作需求时，只需修改操作类呢？
    访问模式就可以实现这样的需求。在该模式中，数据结构与处理被分离开来。编写一个
    表示“访问者”的类来访问数据 中的元素,并把对各元素的处理交给访问者类。这样,当需要增加新的处理时,
    我们只需要修改访问者,然后让数据结构可以接受访问者的访问即可。
### 中介者模式
### 解释器模式